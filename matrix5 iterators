#include <iostream>
#include <string>
#include <vector>
#include <iterator>
#include <tuple>
#include <cassert>

#define assertm(exp, msg) assert(((void)msg, exp))

template<typename T>
class Iterator {
private:
    std::vector<T> *it_;
    size_t index_;

public:
    explicit Iterator(std::vector<T> *it, size_t index = 0) : it_(it), index_(index) {}

    explicit Iterator() = default;

    Iterator &operator++() {
        if (index_ + 1 < it_->size()) {
            ++index_;
        } else {
            ++it_;
            index_ = 0;
        }
        return *this;
    }

    Iterator operator++(int) {
        auto tmp = *this;
        if (index_ + 1 < it_->size()) {
            ++index_;
        } else {
            ++it_;
            index_ = 0;
        }

        return tmp;
    }

    T &operator*() {
        return (*it_)[index_];
    }

    auto get_it() {
        return it_;
    }

    auto get_index() {
        return index_;
    }

    bool operator==(Iterator &second) const {
        return this->it_ == second.it_ && index_ == second.index_;
    }

    bool operator!=(Iterator &second) const {
        return this->it_ != second.it_ || index_ != second.index_;
    }
};

template<typename T>
class const_iterator {
    const std::vector<T> *ptr_;
    size_t index_ = 0;

public:
    explicit const_iterator(const std::vector<T> *ptr, size_t index = 0)
            : ptr_(ptr), index_(index) {}

    explicit const_iterator() = default;

    const_iterator &operator++() {
        if (index_ + 1 < ptr_->size()) {
            ++index_;
        } else {
            ++ptr_;
            index_ = 0;
        }
        return *this;
    }

    const_iterator operator++(int) {
        auto temp = *this;
        ++ptr_;
        return temp;
    }

    const T &operator*() const {
        return (*ptr_)[index_];
    }

    auto get_ptr() {
        return ptr_;
    }

    auto get_index() const {
        return index_;
    }

    bool operator==(const_iterator<T> &second) const {
        return (this->ptr_ == second.ptr_) && this->index_ == second.get_index();
    }

    bool operator!=(const_iterator<T> &second) const {
        return (this->ptr_ != second.ptr_) || this->index_ != second.get_index();
    }
};

template<typename T>
class Matrix {
private:
    std::vector<std::vector<T>> matr_;
    Iterator<T> begin_;
    Iterator<T> end_;
    const_iterator<T> cbegin_;
    const_iterator<T> cend_;

public:
    explicit Matrix(std::vector<std::vector<T>> &matr) : matr_(matr),
                                                         begin_(Iterator(matr.data())),
                                                         end_(Iterator(matr.data() +
                                                                       matr.size())),
                                                         cbegin_(const_iterator(matr.data())),
                                                         cend_(const_iterator(matr.data() +
                                                                              matr.size())) {}

    [[nodiscard]] auto begin() {
        return begin_;
    }

    [[nodiscard]] auto begin() const {
        return cbegin_;
    }

    [[nodiscard]] auto end() {
        return end_;
    }

    [[nodiscard]] auto end() const {
        return cend_;
    }
    // explicit Matrix(const std::vector<std::vector<T>> &&matr) : matr_(std::move(matr)) {}

    Matrix(const Matrix &second) = default;

    Matrix(Matrix &second) = default;

    Matrix(Matrix &&second) noexcept = default;

    [[nodiscard]] const std::vector<std::vector<T>> &get_matrix() const {
        return matr_;
    }

    [[nodiscard]]  std::vector<std::vector<T>> &get_matrix() {
        return matr_;
    }

    [[nodiscard]] std::pair<size_t, size_t> size() const {
        return std::make_pair(matr_.size(), matr_[0].size());
    }

    Matrix &operator=(const Matrix &second) = default;

    Matrix &operator=(Matrix &&second) noexcept = default;

    Matrix &operator+=(const Matrix &second) {
        const auto &matrix_second = second.get_matrix();
        for (size_t i = 0; i < matr_.size(); ++i) {
            for (size_t j = 0; j < matr_[0].size(); ++j) {
                matr_[i][j] += matrix_second[i][j];
            }
        }
        return *this;
    }

    Matrix operator+(const Matrix &second) const {
        Matrix new_matr(*this);
        return new_matr += second;
    }

    template<class U>
    Matrix &operator*=(const U &value) {
        for (size_t i = 0; i < matr_.size(); ++i) {
            for (size_t j = 0; j < matr_[0].size(); ++j) {
                matr_[i][j] *= value;
            }
        }
        return *this;
    }

    template<class U>
    Matrix operator*(const U &value) const {
        Matrix new_matr(*this);
        return new_matr *= value;
    }

    Matrix &transpose() {
        std::vector<std::vector<T>> trans_v(matr_[0].size(), std::vector<T>(matr_.size()));
        for (size_t i = 0; i < trans_v.size(); ++i) {
            for (size_t j = 0; j < trans_v[0].size(); ++j) {
                trans_v[i][j] = matr_[j][i];
            }
        }
        *this = Matrix(trans_v);
        return *this;
    }

    [[nodiscard]] Matrix transposed() const {
        std::vector<std::vector<T>> trans_v(matr_[0].size(), std::vector<T>(matr_.size()));
        for (size_t i = 0; i < trans_v.size(); ++i) {
            for (size_t j = 0; j < trans_v[0].size(); ++j) {
                trans_v[i][j] = matr_[j][i];
            }
        }
        return Matrix(trans_v);
    }

    Matrix &operator*=(const Matrix &other) {
        assertm(matr_[0].size() == other.get_matrix().size(), "NOT AVAILABLE SIZES");
        std::vector<std::vector<T>> mult_v(matr_.size(),
                                           std::vector<T>(other.get_matrix()[0].size()));
        for (size_t i = 0; i < matr_.size(); ++i) {
            for (size_t k = 0; k < other.get_matrix()[0].size(); ++k) {
                for (size_t j = 0; j < matr_[0].size(); ++j) {
                    mult_v[i][k] += matr_[i][j] * other.get_matrix()[j][k];
                }
            }
        }
        *this = Matrix(mult_v);
        return *this;
    }

    Matrix operator*(const Matrix &other) {
        assertm(matr_[0].size() == other.get_matrix().size(), "NOT AVAILABLE SIZES");
        Matrix new_matr(*this);
        return new_matr *= other;
    }
};

template<typename T>
std::ostream &operator<<(std::ostream &out, const Matrix<T> &m) {
    const auto &tmp_matrix = m.get_matrix();
    for (size_t i = 0; i < tmp_matrix.size() - 1; ++i) {
        out << tmp_matrix[i][0];
        for (size_t j = 1; j < tmp_matrix[0].size(); ++j) {
            out << '\t' << tmp_matrix[i][j];
        }
        out << '\n';
    }
    out << tmp_matrix[tmp_matrix.size() - 1][0];
    for (size_t j = 1; j < tmp_matrix[0].size(); ++j) {
        out << '\t' << tmp_matrix[tmp_matrix.size() - 1][j];
    }
    return out;
}
